import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;


// getters and constructors are
// automatically generated by the annotations

@Getter
@NoArgsConstructor
@ToString
@EqualsAndHashCode
public class Converter {

    public static double convert(String bits) {
        Spring spring = bitsToSpring(bits);
        int sampleSize = 1024;
        double t0 = 0;
        double t1 = 2 * Math.PI;

        double[] coordinates = getOscillations(spring, t0, t1, sampleSize);
        Complex[] amplitudes = getAmplitudes(coordinates, (t1 - t0) / sampleSize);
        List<Double> frequencies = getFrequencies(amplitudes, (t1 - t0) / sampleSize);

        return getDecimalFromFrequencies(amplitudes, frequencies);
    }


    private static double[] getOscillations(Spring spring, double start, double end, int n) {
        return spring.move(start, end, end / n, 1, 0, 0.001);
    }

    private static Complex[] getAmplitudes(double[] coordinates, double rate) {
        Complex[] amplitudes = doubleToComplex(Arrays.copyOf(coordinates, coordinates.length - 1));
        FT.fft(amplitudes);
        return amplitudes;
    }

    private static List<Double> getFrequencies(Complex[] amplitudes, double rate) {
        return FT.fftfreq(amplitudes.length, rate);
    }

    private static double getDecimalFromFrequencies(Complex[] amplitudes, List<Double> frequencies) {
        // TO DO
        return 0;
    }

    private static Complex[] doubleToComplex(double[] doubles) {
        Complex[] cinput = new Complex[doubles.length];
        for (int i = 0; i < doubles.length; i++) {
            cinput[i] = new Complex(doubles[i], 0.0);
        }
        return cinput;
    }

    private static Spring bitsToSpring(String bits) {
        validate(bits);
        StringBuilder expression = new StringBuilder("[");
        List<Spring> springs = new ArrayList<>();
        String bitsReversed = new StringBuilder(bits).reverse().toString();

        for (int index = 0; index < bitsReversed.length(); index++) {
            if(bitsReversed.charAt(index) == '1') {
                expression.append("{}");
                springs.add(new Spring(Math.pow(2, index)));
            }
        }
        expression.append("]");
        return SpringArray.equivalentSpring(expression.toString(), listToArray(springs));
    }

    private static Spring[] listToArray(List<Spring> springList) {
        Spring[] springArray = new Spring[springList.size()];
        int j = 0;
        for (Spring spring : springList) {
            springArray[j] = spring;
            j++;
        }
        return springArray;
    }

    private static void validate(String bits) {
        if(bits.length() != 8) {
            throw new IllegalArgumentException("Number of inputted bits should be 8, not " + bits.length());
        }

        for (int i = 0; i < bits.length(); i++) {
            if(bits.charAt(i) != '0' && bits.charAt(i) != '1') {
                throw new IllegalArgumentException("Illegal input " + bits.charAt(i) + ", input should be either 1 or 0");
            }
        }
    }
}
